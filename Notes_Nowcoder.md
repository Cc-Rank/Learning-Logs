# Notes

## Linux系统编程

### GCC 常用参数选项

GCC编译选项                |   说明
-------------             |   ------------- 
`-E`                      |   预处理指定的源文件，不进行编译
`-S`                      |   编译指定的源文件，但是不进行汇编
`-c`                      |   编译、汇编指定的源文件，但是不进行链接
`-o [file1] [file2]` / `[file2] -o [file1]` |   将文件 file2 编译成可执行文件 file1
`-I directory`            |   指定 include 包含文件的搜索目录
`-g`                      |   在编译的时候，生成调试信息，该程序可以被调试器调试
`-D`                      |   在程序编译的时候，指定一个宏
`-w`                      |   不生成任何警告信息
`-Wall`                   |   生成所有警告信息
`-On`                     |   n的取值范围：0~3。编译器的优化选项的4个级别，`-O0` 表示没有优化，`-O1` 为缺省值，`-O3` 优化级别最高
`-l`                      |   在程序编译的时候，指定使用的库
`-L`                      |   指定编译的时候，搜索的库的路径。
`-fPIC/fpic`              |   生成与位置无关的代码
`-shared`                 |   生成共享目标文件，通常用在建立共享库时
`-std`                    |   指定 C 方言，如:`-std=c99`，`gcc` 默认的方言是 GNU C

一个简单的使用样例：`gcc main.c -o app -I ./include/ -l calc -L ./lib/`

### 静态库与动态库

- 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。
- 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。
- 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。
- 库的好处：1.代码保密 2.方便部署和分发

#### 工作原理

- 静态库：`GCC` 进行链接时，会把静态库中代码打包到可执行程序中
- 动态库：`GCC` 进行链接时，动态库的代码不会被打包到可执行程序中
  - 程序启动之后，动态库会被动态加载到内存中，通过 `ldd`（list dynamic dependencies）命令检查动态库依赖关系
  - 如何定位共享库文件呢？
当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于`elf` 格式的可执行程序，是由 `ld-linux.so` 来完成的，它先后搜索 `elf` 文件的 `DT_RPATH` 段 ——> 环境变量 `LD_LIBRARY_PATH` ——> `/etc/ld.so.cache` 文件列表 ——> `/lib/`，`/usr/lib` 目录找到库文件后将其载入内存。

#### 优缺点

静态库                                    |   动态库
----------                               |   --------
静态库被打包到应用程序中加载速度快          |   加载速度比静态库慢
发布程序无需提供静态库，移植方便            |   发布程序时需要提供依赖的动态库
----------                               |   --------
消耗系统资源，浪费内存                     |   可以控制何时加载动态库
更新、部署、发布麻烦                       |   更新、部署、发布简单
----------                               |   可以实现进程间资源共享（共享库）

#### Makefile

```makefile
#定义变量
# add.c sub.c main.c mult.c div.c
src=$(wildcard ./*.c)
objs=$(patsubst %.c, %.o, $(src))
target=app
$(target):$(objs)
    $(CC) $(objs) -o $(target)

%.o:%.c
    $(CC) -c $< -o $@

.PHONY:clean
clean:
    rm $(objs) -f
```

预定义变量:

- `AR`：归档维护程序的名称，默认值为 `ar`；
- `CC`：C 编译器的名称，默认值为 `cc`；
- `CXX`：C++ 编译器的名称，默认值为 `g++`；
- `$@`：目标的完整名称；
- `$<`：第一个依赖文件的名称；
- `$^`：所有的依赖文件；

获取变量的值: `$(变量名)`

`%`：通配符，匹配一个字符串，两个 `%` 匹配的是同一个字符串，例：

```makefile
%.o:%.c
    gcc -c $< -o $@
```

`$(wildcard PATTERN...)`

- 功能：获取指定目录下指定类型的文件列表；
- 参数：`PATTERN` 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔；
- 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔；
- 示例：`makefilesrc=$(wildcard ./*.c)`

`$(patsubst <pattern>,<replacement>,<text>)`

- 功能：功能：查找 `<text>` 中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式 `<pattern>`，如果匹配的话，则以 `<replacement>` 替换；
- 参数：`<pattern>` 可以包括通配符`%`，表示任意长度的字串。如果 `<replacement>` 中也包含`%`，那么，`<replacement>` 中的这个 `%` 将是 `<pattern>` 中的那个 `%` 所代表的字串。(可以用 `\` 来转义，以 `\%` 来表示真实含义的 `%` 字符)；
- 返回：函数返回被替换过后的字符串；
- 示例：`objs=$(patsubst %.c, %.o, $(src))`
